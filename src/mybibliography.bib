@misc{HornGraph,
    title={Exploring Representation of Horn Clauses using GNNs},
    author={Chencheng Liang and Philipp R{\"u}mmer and Marc Brockschmidt},
    year={2022},
}


@Article{Leroux2016,
author="Leroux, J{\'e}r{\^o}me
and R{\"u}mmer, Philipp
and Suboti{\'{c}}, Pavle",
title="Guiding {Craig} interpolation with domain-specific abstractions",
journal="Acta Informatica",
year="2016",
month="Jun",
day="01",
volume="53",
number="4",
pages="387--424",
abstract="Craig interpolation is a standard method to construct and refine abstractions in model checking. To obtain abstractions that are suitable for the verification of software programs or hardware designs, model checkers rely on theorem provers to find the right interpolants, or interpolants containing the right predicates, in a generally infinite lattice of interpolants for any given interpolation problem. We present a semantic and solver-independent framework for systematically exploring interpolant lattices, based on the notion of interpolation abstraction. We discuss how interpolation abstractions can be constructed for a variety of logics, and how they can be applied in the context of software model checking.",
issn="1432-0525",
doi="10.1007/s00236-015-0236-z",
url="https://doi.org/10.1007/s00236-015-0236-z"
}


@InProceedings{10.1007/978-3-319-57288-8_18,
author="Demyanova, Yulia
and R{\"u}mmer, Philipp
and Zuleger, Florian",
editor="Barrett, Clark
and Davies, Misty
and Kahsai, Temesghen",
title="Systematic Predicate Abstraction Using Variable Roles",
booktitle="NASA Formal Methods",
year="2017",
publisher="Springer International Publishing",
address="Cham",
pages="265--281",
abstract="Heuristics for discovering predicates for abstraction are an essential part of software model checkers. Picking the right predicates affects the runtime of a model checker, or determines if a model checker is able to solve a verification task at all. In this paper we present a method to systematically specify heuristics for generating program-specific abstractions. The heuristics can be used to generate initial abstractions, and to guide abstraction refinement through templates provided for Craig interpolation. We describe the heuristics using variable roles, which allow us to pick domain-specific predicates according to the program under analysis. Variable roles identify typical variable usage patterns and can be computed using lightweight static analysis, for instance with the help of off-the-shelf logical programming engines. We implemented a prototype tool which extracts initial predicates and templates for C programs and passes them to the Eldarica model checker in the form of source code annotations. For evaluation, we defined a set of heuristics, motivated by Eldarica's previous built-in heuristics and typical verification benchmarks from the literature and SV-COMP. We evaluate our approach on a set of more than 500 programs, and observe an overall increase in the number of solved tasks by 11.2{\%}, and significant speedup on certain benchmark families.",
isbn="978-3-319-57288-8"
}

@misc{chcBenchmark,
    title={Competition Report: {CHC-COMP-21}},
    author={Grigory Fedyukovich and Philipp R{\"u}mmer},
    year={2021},
    url       = {https://chc-comp.github.io/2021/report.pdf}
}

@INPROCEEDINGS{8603013,  author={H. {Hojjat} and P. {Ruemmer}},  booktitle={2018 Formal Methods in Computer Aided Design (FMCAD)},   title={The {ELDARICA} {Horn} Solver},   year={2018},  volume={},  number={},  pages={1-7},  doi={10.23919/FMCAD.2018.8603013}}

@misc{ruemmer2013disjunctive,
      title={Disjunctive Interpolants for {Horn-clause} Verification (Extended Technical Report)},
      author={Philipp R{\"u}mmer and Hossein Hojjat and Viktor Kuncak},
      year={2013},
      eprint={1301.4973},
      archivePrefix={arXiv},
      primaryClass={cs.LO}
}




@InProceedings{10.1007/10722167_15,
author="Clarke, Edmund
and Grumberg, Orna
and Jha, Somesh
and Lu, Yuan
and Veith, Helmut",
editor="Emerson, E. Allen and Sistla, Aravinda Prasad",
title="Counterexample-Guided Abstraction Refinement ",
booktitle="Computer Aided Verification",
year="2000",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="154--169",
abstract="We present an automatic iterative abstraction-refinement methodology in which the initial abstract model is generated by an automatic analysis of the control structures in the program to be verified. Abstract models may admit erroneous (or ``spurious'') counterexamples. We devise new symbolic techniques which analyze such counterexamples and refine the abstract model correspondingly. The refinement algorithm keeps the size of the abstract state space small due to the use of abstraction functions which distinguish many degrees of abstraction for each program variable. We describe an implementation of our methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches and 10000 lines of SMV code confirm the effectiveness of our approach.",
isbn="978-3-540-45047-4"
}


@article{10.1145/2345156.2254112,
author = {Grebenshchikov, Sergey and Lopes, Nuno P. and Popeea, Corneliu and Rybalchenko, Andrey},
title = {Synthesizing Software Verifiers from Proof Rules},
year = {2012},
issue_date = {June 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2345156.2254112},
doi = {10.1145/2345156.2254112},
abstract = {Automatically generated tools can significantly improve programmer productivity. For example, parsers and dataflow analyzers can be automatically generated from declarative specifications in the form of grammars, which tremendously simplifies the task of implementing a compiler. In this paper, we present a method for the automatic synthesis of software verification tools. Our synthesis procedure takes as input a description of the employed proof rule, e.g., program safety checking via inductive invariants, and produces a tool that automatically discovers the auxiliary assertions required by the proof rule, e.g., inductive loop invariants and procedure summaries. We rely on a (standard) representation of proof rules using recursive equations over the auxiliary assertions. The discovery of auxiliary assertions, i.e., solving the equations, is based on an iterative process that extrapolates solutions obtained for finitary unrollings of equations. We show how our method synthesizes automatic safety and liveness verifiers for programs with procedures, multi-threaded programs, and functional programs. Our experimental comparison of the resulting verifiers with existing state-of-the-art verification tools confirms the practicality of the approach.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {405–416},
numpages = {12},
keywords = {software verification, software model checking, verification tool synthesis, proof rules}
}

@inproceedings{10.1145/2254064.2254112,
author = {Grebenshchikov, Sergey and Lopes, Nuno P. and Popeea, Corneliu and Rybalchenko, Andrey},
title = {Synthesizing Software Verifiers from Proof Rules},
year = {2012},
isbn = {9781450312059},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2254064.2254112},
doi = {10.1145/2254064.2254112},
abstract = {Automatically generated tools can significantly improve programmer productivity. For example, parsers and dataflow analyzers can be automatically generated from declarative specifications in the form of grammars, which tremendously simplifies the task of implementing a compiler. In this paper, we present a method for the automatic synthesis of software verification tools. Our synthesis procedure takes as input a description of the employed proof rule, e.g., program safety checking via inductive invariants, and produces a tool that automatically discovers the auxiliary assertions required by the proof rule, e.g., inductive loop invariants and procedure summaries. We rely on a (standard) representation of proof rules using recursive equations over the auxiliary assertions. The discovery of auxiliary assertions, i.e., solving the equations, is based on an iterative process that extrapolates solutions obtained for finitary unrollings of equations. We show how our method synthesizes automatic safety and liveness verifiers for programs with procedures, multi-threaded programs, and functional programs. Our experimental comparison of the resulting verifiers with existing state-of-the-art verification tools confirms the practicality of the approach.},
booktitle = {Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {405–416},
numpages = {12},
keywords = {software model checking, software verification, verification tool synthesis, proof rules},
location = {Beijing, China},
series = {PLDI '12}
}


@inbook{Bjorner2015,
author = {Bjørner, Nikolaj and Gurfinkel, Arie and McMillan, Ken and Rybalchenko, Andrey},
year = {2015},
month = {09},
pages = {24-51},
title = {Horn clause solvers for program verification},
isbn = {978-3-319-23533-2},
doi = {10.1007/978-3-319-23534-9\_2}
}


@article{10.2307/2268661,
 ISSN = {00224812},
 URL = {http://www.jstor.org/stable/2268661},
 author = {Alfred Horn},
 journal = {The Journal of Symbolic Logic},
 number = {1},
 pages = {14--21},
 publisher = {Association for Symbolic Logic},
 title = {On Sentences Which are True of Direct Unions of Algebras},
 volume = {16},
 year = {1951}
}

@InProceedings{10.1007/3-540-63166-6_10,
author="Graf, Susanne
and Saidi, Hassen",
editor="Grumberg, Orna",
title="Construction of abstract state graphs with PVS",
booktitle="Computer Aided Verification",
year="1997",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="72--83",
abstract="In this paper, we propose a method for the automatic construction of an abstract state graph of an arbitrary system using the Pvs theorem prover.",
isbn="978-3-540-69195-2"
}

@article{10.1145/982962.964021,
author = {Henzinger, Thomas A. and Jhala, Ranjit and Majumdar, Rupak and McMillan, Kenneth L.},
title = {Abstractions from Proofs},
year = {2004},
issue_date = {January 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/982962.964021},
doi = {10.1145/982962.964021},
abstract = {The success of model checking for large programs depends crucially on the ability to efficiently construct parsimonious abstractions. A predicate abstraction is parsimonious if at each control location, it specifies only relationships between current values of variables, and only those which are required for proving correctness. Previous methods for automatically refining predicate abstractions until sufficient precision is obtained do not systematically construct parsimonious abstractions: predicates usually contain symbolic variables, and are added heuristically and often uniformly to many or all control locations at once. We use Craig interpolation to efficiently construct, from a given abstract error trace which cannot be concretized, a parsominous abstraction that removes the trace. At each location of the trace, we infer the relevant predicates as an interpolant between the two formulas that define the past and the future segment of the trace. Each interpolant is a relationship between current values of program variables, and is relevant only at that particular program location. It can be found by a linear scan of the proof of infeasibility of the trace.We develop our method for programs with arithmetic and pointer expressions, and call-by-value function calls. For function calls, Craig interpolation offers a systematic way of generating relevant predicates that contain only the local variables of the function and the values of the formal parameters when the function was called. We have extended our model checker Blast with predicate discovery by Craig interpolation, and applied it successfully to C programs with more than 130,000 lines of code, which was not possible with approaches that build less parsimonious abstractions.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {232–244},
numpages = {13},
keywords = {counterexample analysis, predicate abstraction, software model checking}
}

@inproceedings{10.1145/964001.964021,
author = {Henzinger, Thomas A. and Jhala, Ranjit and Majumdar, Rupak and McMillan, Kenneth L.},
title = {Abstractions from Proofs},
year = {2004},
isbn = {158113729X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/964001.964021},
doi = {10.1145/964001.964021},
abstract = {The success of model checking for large programs depends crucially on the ability to efficiently construct parsimonious abstractions. A predicate abstraction is parsimonious if at each control location, it specifies only relationships between current values of variables, and only those which are required for proving correctness. Previous methods for automatically refining predicate abstractions until sufficient precision is obtained do not systematically construct parsimonious abstractions: predicates usually contain symbolic variables, and are added heuristically and often uniformly to many or all control locations at once. We use Craig interpolation to efficiently construct, from a given abstract error trace which cannot be concretized, a parsominous abstraction that removes the trace. At each location of the trace, we infer the relevant predicates as an interpolant between the two formulas that define the past and the future segment of the trace. Each interpolant is a relationship between current values of program variables, and is relevant only at that particular program location. It can be found by a linear scan of the proof of infeasibility of the trace.We develop our method for programs with arithmetic and pointer expressions, and call-by-value function calls. For function calls, Craig interpolation offers a systematic way of generating relevant predicates that contain only the local variables of the function and the values of the formal parameters when the function was called. We have extended our model checker Blast with predicate discovery by Craig interpolation, and applied it successfully to C programs with more than 130,000 lines of code, which was not possible with approaches that build less parsimonious abstractions.},
booktitle = {Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {232–244},
numpages = {13},
keywords = {counterexample analysis, software model checking, predicate abstraction},
location = {Venice, Italy},
series = {POPL '04}
}






@article{10.2307/2963593,
 ISSN = {00224812},
 URL = {http://www.jstor.org/stable/2963593},
 author = {William Craig},
 journal = {The Journal of Symbolic Logic},
 number = {3},
 pages = {250--268},
 publisher = {Association for Symbolic Logic},
 title = {Linear Reasoning. A New Form of the Herbrand-Gentzen Theorem},
 volume = {22},
 year = {1957}
}




@article{DBLP:journals/corr/abs-1806-01261,
  author    = {Peter W. Battaglia and
               Jessica B. Hamrick and
               Victor Bapst and
               Alvaro Sanchez{-}Gonzalez and
               Vin{\'{\i}}cius Flores Zambaldi and
               Mateusz Malinowski and
               Andrea Tacchetti and
               David Raposo and
               Adam Santoro and
               Ryan Faulkner and
               {\c{C}}aglar G{\"{u}}l{\c{c}}ehre and
               H. Francis Song and
               Andrew J. Ballard and
               Justin Gilmer and
               George E. Dahl and
               Ashish Vaswani and
               Kelsey R. Allen and
               Charles Nash and
               Victoria Langston and
               Chris Dyer and
               Nicolas Heess and
               Daan Wierstra and
               Pushmeet Kohli and
               Matthew Botvinick and
               Oriol Vinyals and
               Yujia Li and
               Razvan Pascanu},
  title     = {Relational inductive biases, deep learning, and graph networks},
  journal   = {CoRR},
  volume    = {abs/1806.01261},
  year      = {2018},
  url       = {http://arxiv.org/abs/1806.01261},
  archivePrefix = {arXiv},
  eprint    = {1806.01261},
  timestamp = {Wed, 24 Jul 2019 18:56:21 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1806-01261.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@article{DBLP:journals/corr/abs-1711-00740,
  author    = {Miltiadis Allamanis and
               Marc Brockschmidt and
               Mahmoud Khademi},
  title     = {Learning to Represent Programs with Graphs},
  journal   = {CoRR},
  volume    = {abs/1711.00740},
  year      = {2017},
  url       = {http://arxiv.org/abs/1711.00740},
  archivePrefix = {arXiv},
  eprint    = {1711.00740},
  timestamp = {Mon, 13 Aug 2018 16:46:52 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/corr/abs-1711-00740},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@misc{tech-report,
  doi = {10.48550/ARXIV.2206.06986},
 
  url = {https://arxiv.org/abs/2206.06986},
  
  author = {Liang, Chencheng and Rümmer, Philipp and Brockschmidt, Marc},
  
  keywords = {Artificial Intelligence (cs.AI), Machine Learning (cs.LG), FOS: Computer and information sciences, FOS: Computer and information sciences},
  
  title = {Exploring Representation of Horn Clauses using GNNs},
  
  publisher = {arXiv},
  
  year = {2022},
  
  copyright = {arXiv.org perpetual, non-exclusive license}
}


@article{DBLP:journals/corr/abs-1806-07336,
  author    = {Tal Ben{-}Nun and
               Alice Shoshana Jakobovits and
               Torsten Hoefler},
  title     = {Neural Code Comprehension: {A} Learnable Representation of Code Semantics},
  journal   = {CoRR},
  volume    = {abs/1806.07336},
  year      = {2018},
  url       = {http://arxiv.org/abs/1806.07336},
  eprinttype = {arXiv},
  eprint    = {1806.07336},
  timestamp = {Mon, 13 Aug 2018 16:45:58 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1806-07336.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@INPROCEEDINGS{1281665,  author={Lattner, C. and Adve, V.},  booktitle={International Symposium on Code Generation and Optimization, 2004. CGO 2004.},   title={{LLVM}: a compilation framework for lifelong program analysis  amp; transformation},   year={2004},  volume={},  number={},  pages={75-86},  doi={10.1109/CGO.2004.1281665}}


@inproceedings{Mikolov2010RecurrentNN,
  title={Recurrent neural network based language model},
  author={Tomas Mikolov and Martin Karafi{\'a}t and Luk{\'a}s Burget and Jan Honza Cernock{\'y} and Sanjeev Khudanpur},
  booktitle={INTERSPEECH},
  year={2010}
}

@inproceedings{10.1145/3213846.3213876,
author = {Le, Tien-Duy B. and Lo, David},
title = {Deep Specification Mining},
year = {2018},
isbn = {9781450356992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3213846.3213876},
doi = {10.1145/3213846.3213876},
abstract = {Formal specifcations are essential but usually unavailable in software systems. Furthermore, writing these specifcations is costly and requires skills from developers. Recently, many automated techniques have been proposed to mine specifcations in various formats including fnite-state automaton (FSA). However, more works in specifcation mining are needed to further improve the accuracy of the inferred specifcations. In this work, we propose Deep Specifcation Miner (DSM), a new approach that performs deep learning for mining FSA-based specifcations. Our proposed approach uses test case generation to generate a richer set of execution traces for training a Recurrent Neural Network Based Language Model (RNNLM). From these execution traces, we construct a Prefx Tree Acceptor (PTA) and use the learned RNNLM to extract many features. These features are subsequently utilized by clustering algorithms to merge similar automata states in the PTA for constructing a number of FSAs. Then, our approach performs a model selection heuristic to estimate F-measure of FSAs and returns the one with the highest estimated Fmeasure. We execute DSM to mine specifcations of 11 target library classes. Our empirical analysis shows that DSM achieves an average F-measure of 71.97%, outperforming the best performing baseline by 28.22%. We also demonstrate the value of DSM in sandboxing Android apps.},
booktitle = {Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis},
pages = {106–117},
numpages = {12},
keywords = {Deep Learning, Specification Mining},
location = {Amsterdam, Netherlands},
series = {ISSTA 2018}
}


@article{heuristicSelectionForTP,
author = {Bridge, James and Holden, Sean and Paulson, Lawrence},
year = {2014},
month = {08},
pages = {},
title = {Machine Learning for First-Order Theorem Proving},
volume = {53},
journal = {Journal of Automated Reasoning},
doi = {10.1007/s10817-014-9301-5}
}




@INPROCEEDINGS{9286080,  author={Richter, Cedric and Wehrheim, Heike},  booktitle={2020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)},   title={Attend and Represent: A Novel View on Algorithm Selection for Software Verification},   year={2020},  volume={},  number={},  pages={1016-1028},  doi={}}

@ARTICLE{Richter2020-yh,
  title    = "Algorithm selection for software validation based on graph
              kernels",
  author   = "Richter, Cedric and H{\"u}llermeier, Eyke and Jakobs,
              Marie-Christine and Wehrheim, Heike",
  abstract = "Algorithm selection is the task of choosing an algorithm from a
              given set of candidate algorithms when faced with a particular
              problem instance. Algorithm selection via machine learning (ML)
              has recently been successfully applied for various problem
              classes, including computationally hard problems such as SAT. In
              this paper, we study algorithm selection for software validation,
              i.e., the task of choosing a software validation tool for a given
              validation instance. A validation instance consists of a program
              plus properties to be checked on it. The application of machine
              learning techniques to this task first of all requires an
              appropriate representation of software. To this end,we propose a
              dedicated kernel function, which compares two programs in terms
              of their similarity, thus making the algorithm selection task
              amenable to kernel-based machine learning methods. Our kernel
              operates on a graph representation of source code mixing elements
              of control-flow and program-dependence graphs with abstract
              syntax trees.Thus, given two such representations as input, the
              kernel function yields a real-valued score that can be
              interpreted as a degree of similarity. We experimentally evaluate
              our kernel in two learning scenarios, namely a classification and
              a ranking problem: (1) selecting between a verification and a
              testing tool for bug finding (i.e., property violation), and (2)
              ranking several verification tools,from presumably best to worst,
              for property proving. The evaluation, which is based on data sets
              from the annual software verification competition SV-COMP,
              demonstrates our kernel to generalize well and to achieve rather
              high prediction accuracy, both for the classification and the
              ranking task.",
  journal  = "Automated Software Engineering",
  volume   =  27,
  number   =  1,
  pages    = "153--186",
  month    =  jun,
  year     =  2020
}


@misc{vaswani2017attention,
      title={Attention Is All You Need},
      author={Ashish Vaswani and Noam Shazeer and Niki Parmar and Jakob Uszkoreit and Llion Jones and Aidan N. Gomez and Lukasz Kaiser and Illia Polosukhin},
      year={2017},
      eprint={1706.03762},
      archivePrefix={arXiv},
      primaryClass={cs.CL}
}

@book{kernelMethods,
author = {Schölkopf, Bernhard and Smola, A.J.},
year = {2001},
month = {01},
pages = {},
title = {Smola, A.: Learning with Kernels - Support Vector Machines, Regularization, Optimization and Beyond. MIT Press, Cambridge, MA},
volume = {98},
journal = {Journal of The American Statistical Association - J AMER STATIST ASSN}
}

@article{cortes1995support,
  title={Support-vector networks},
  author={Cortes, Corinna and Vapnik, Vladimir},
  journal={Machine learning},
  volume={20},
  number={3},
  pages={273--297},
  year={1995},
  publisher={Springer}
}


@book{10.5555/1162254,
author = {Rasmussen, Carl Edward and Williams, Christopher K. I.},
title = {Gaussian Processes for Machine Learning (Adaptive Computation and Machine Learning)},
year = {2005},
isbn = {026218253X},
publisher = {The MIT Press}
}

@inproceedings{Si2018LearningLI,
  title={Learning Loop Invariants for Program Verification},
  author={Xujie Si and Hanjun Dai and Mukund Raghothaman and M. Naik and Le Song},
  booktitle={NeurIPS},
  year={2018}
}




@misc{https://doi.org/10.48550/arxiv.1312.6114,
  doi = {10.48550/ARXIV.1312.6114},
  url = {https://arxiv.org/abs/1312.6114},
  author = {Kingma, Diederik P and Welling, Max},
  keywords = {Machine Learning (stat.ML), Machine Learning (cs.LG), FOS: Computer and information sciences, FOS: Computer and information sciences},
  title = {Auto-Encoding Variational {Bayes}},
  publisher = {arXiv},
  year = {2013},
  copyright = {arXiv.org perpetual, non-exclusive license}
}


@misc{https://doi.org/10.48550/arxiv.1802.08786,
  doi = {10.48550/ARXIV.1802.08786},
  url = {https://arxiv.org/abs/1802.08786},
  author = {Dai, Hanjun and Tian, Yingtao and Dai, Bo and Skiena, Steven and Song, Le},
  keywords = {Machine Learning (cs.LG), Computation and Language (cs.CL), FOS: Computer and information sciences, FOS: Computer and information sciences},
  title = {Syntax-Directed Variational Autoencoder for Structured Data},
  publisher = {arXiv},
  year = {2018},
  copyright = {arXiv.org perpetual, non-exclusive license}
}



@incollection{NIPS2017_6871,
title = {Premise Selection for Theorem Proving by Deep Graph Embedding},
author = {Wang, Mingzhe and Tang, Yihe and Wang, Jian and Deng, Jia},
booktitle = {Advances in Neural Information Processing Systems 30},
editor = {I. Guyon and U. V. Luxburg and S. Bengio and H. Wallach and R. Fergus and S. Vishwanathan and R. Garnett},
pages = {2786--2796},
year = {2017},
publisher = {Curran Associates, Inc.},
url = {http://papers.nips.cc/paper/6871-premise-selection-for-theorem-proving-by-deep-graph-embedding.pdf}
}



@article{DBLP:journals/corr/abs-1905-10006,
  author    = {Aditya Paliwal and
               Sarah M. Loos and
               Markus N. Rabe and
               Kshitij Bansal and
               Christian Szegedy},
  title     = {Graph Representations for Higher-Order Logic and Theorem Proving},
  journal   = {CoRR},
  volume    = {abs/1905.10006},
  year      = {2019},
  url       = {http://arxiv.org/abs/1905.10006},
  archivePrefix = {arXiv},
  eprint    = {1905.10006},
  timestamp = {Wed, 29 May 2019 11:27:50 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1905-10006.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@article{DBLP:journals/corr/abs-1905-10006,
  author    = {Aditya Paliwal and
               Sarah M. Loos and
               Markus N. Rabe and
               Kshitij Bansal and
               Christian Szegedy},
  title     = {Graph Representations for Higher-Order Logic and Theorem Proving},
  journal   = {CoRR},
  volume    = {abs/1905.10006},
  year      = {2019},
  url       = {http://arxiv.org/abs/1905.10006},
  archivePrefix = {arXiv},
  eprint    = {1905.10006},
  timestamp = {Wed, 29 May 2019 11:27:50 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1905-10006.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}





@article{DBLP:journals/corr/abs-1903-04671,
  author    = {Daniel Selsam and
               Nikolaj Bj{\o}rner},
  title     = {NeuroCore: Guiding High-Performance {SAT} Solvers with Unsat-Core
               Predictions},
  journal   = {CoRR},
  volume    = {abs/1903.04671},
  year      = {2019},
  url       = {http://arxiv.org/abs/1903.04671},
  archivePrefix = {arXiv},
  eprint    = {1903.04671},
  timestamp = {Sun, 31 Mar 2019 19:01:24 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1903-04671.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/corr/abs-1802-03685,
  author    = {Daniel Selsam and
               Matthew Lamm and
               Benedikt B{\"{u}}nz and
               Percy Liang and
               Leonardo de Moura and
               David L. Dill},
  title     = {Learning a {SAT} Solver from Single-Bit Supervision},
  journal   = {CoRR},
  volume    = {abs/1802.03685},
  year      = {2018},
  url       = {http://arxiv.org/abs/1802.03685},
  archivePrefix = {arXiv},
  eprint    = {1802.03685},
  timestamp = {Mon, 13 Aug 2018 16:47:15 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1802-03685.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}



@article{DBLP:journals/corr/GilmerSRVD17,
  author    = {Justin Gilmer and
               Samuel S. Schoenholz and
               Patrick F. Riley and
               Oriol Vinyals and
               George E. Dahl},
  title     = {Neural Message Passing for Quantum Chemistry},
  journal   = {CoRR},
  volume    = {abs/1704.01212},
  year      = {2017},
  url       = {http://arxiv.org/abs/1704.01212},
  archivePrefix = {arXiv},
  eprint    = {1704.01212},
  timestamp = {Mon, 13 Aug 2018 16:48:42 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/GilmerSRVD17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@ARTICLE{4700287,  author={F. {Scarselli} and M. {Gori} and A. C. {Tsoi} and M. {Hagenbuchner} and G. {Monfardini}},  journal={IEEE Transactions on Neural Networks},   title={The Graph Neural Network Model},   year={2009},  volume={20},  number={1},  pages={61-80},  doi={10.1109/TNN.2008.2005605}}

@misc{li2017gated,
  doi = {10.48550/ARXIV.1511.05493},
  url = {https://arxiv.org/abs/1511.05493},
  author = {Li, Yujia and Tarlow, Daniel and Brockschmidt, Marc and Zemel, Richard},
  keywords = {Machine Learning (cs.LG), Artificial Intelligence (cs.AI), Neural and Evolutionary Computing (cs.NE), Machine Learning (stat.ML), FOS: Computer and information sciences, FOS: Computer and information sciences},
  title = {Gated Graph Sequence Neural Networks},
  publisher = {arXiv},
  year = {2015},
  copyright = {arXiv.org perpetual, non-exclusive license}
}